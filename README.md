# Smart Pointers 

В этой задаче вам предстоит реализовать аналоги шаблонов std::shared_ptr и std::weak_ptr. 

## SharedPtr

Необходимо реализовать класс ```SharedPtr<T>```, который должен содержать следующие методы: 

(За описанием работы методов можно обращаться к cppref)

- Конструкторы
  - SharedPtr() - по умолчанию 
  - SharedPtr(Y* ptr) - конструктор от c-style указателя. Может быть как указатель на T, так и указатель на наследника T
  - SharedPtr(const SharedPtr<Y>&) - конструктор копирования 
  - SharedPtr(SharedPtr<Y>&&) - move-конструктор 
- operator=(const SharedPtr<Y>&) - оператор присваивания копированием
- operator=(SharedPtr<Y>&&) - оператор присваивания перемещением
- Деструктор - если при смерти шаред обнаруживает, что пора уничтожать объект, но объект на самом деле типа Y, где Y наследник T, то объект должен быть уничтожен как Y.
- use_count - возвращает количество шаредов владеющих объектом.
- Метод get для получения c-style указателя
- операторы * и ->
- Метод reset() 

***Note*** Шаред на родителя можно инициализировать шаредом на наследника. Это относится и к конструкторам и к операторам присваивания.

Вне класса необходимо реализовать следующие функции:

- MakeShared - создает SharedPtr из аргументов. Эта функция должна обращаться к new ровно 1 раз. Не забудьте про форвардинг аргументов

## WeakPtr

Необходимо реализовать класс ```WeakPtr<T>```, который должен содержать следующие методы:

- Конструкторы
  - WeakPtr()
  - WeakPtr(const WeakPtr<Y>&)
  - WeakPtr(const SharedPtr<Y>&)
  - WeakPtr(WeakPtr<Y>&&)
- operator=(const WeakPtr<Y>&) - оператор присваивания копированием
- operator=(WeakPtr<Y>&&) - оператор присваивания перемещением
- Деструктор
- expired - возвращает True если объект под виком все еще валиден (на него есть шаред)
- lock - возвращает SharedPtr на объект (если объект еще жив, иначе UB).